[{"path":"https://gsmolinski.github.io/shinybreakpoint/LICENSE.html","id":null,"dir":"","previous_headings":"","what":"MIT License","title":"MIT License","text":"Copyright (c) 2022 Grzegorz Smoliński Permission hereby granted, free charge, person obtaining copy software associated documentation files (“Software”), deal Software without restriction, including without limitation rights use, copy, modify, merge, publish, distribute, sublicense, /sell copies Software, permit persons Software furnished , subject following conditions: copyright notice permission notice shall included copies substantial portions Software. SOFTWARE PROVIDED “”, WITHOUT WARRANTY KIND, EXPRESS IMPLIED, INCLUDING LIMITED WARRANTIES MERCHANTABILITY, FITNESS PARTICULAR PURPOSE NONINFRINGEMENT. EVENT SHALL AUTHORS COPYRIGHT HOLDERS LIABLE CLAIM, DAMAGES LIABILITY, WHETHER ACTION CONTRACT, TORT OTHERWISE, ARISING , CONNECTION SOFTWARE USE DEALINGS SOFTWARE.","code":""},{"path":"https://gsmolinski.github.io/shinybreakpoint/articles/app-structure.html","id":"overview","dir":"Articles","previous_headings":"","what":"Overview","title":"App Structure","text":"shinybreakpoint designed display Shiny app (.e. app runs) parts source code used app allow set breakpoint places displayed source code. Thus clear beginning package two-stage limitations: breakpoint can’t set lines displayed breakpoint won’t set lines displayed Setting breakpoint debugging technique - point (line code) reached, code execution halted, debug mode enabled one can check values objects perform operations temporary environment (.e. changes exist debug mode). one method find unexpected behavior occurred. shinybreakpoint provide new technique Shiny apps - already possible set breakpoint using e.g. RStudio IDE, current solution limitation. Breakpoint can’t set code split multiple files (often case app built modules). Although shinybreakpoint gives solution , makes radical way - code split (least one), separated server part, function.","code":""},{"path":"https://gsmolinski.github.io/shinybreakpoint/articles/app-structure.html","id":"minimal-app-structure","dir":"Articles","previous_headings":"","what":"Minimal App Structure","title":"App Structure","text":"start snippet1 - minimal skeleton needed successfully run Shiny app shinybreakpoint functionality: similar regular Shiny snippet, however one significant difference - server part duplicated. duplication necessary, breakpoint set using shinybreakpoint, session refreshed enable changes code (changes code added chosen line, .. browser()). Refreshment works objects nested functions call server part. words, breakpoint won’t work objects used directly server, objects visible source code. example works, can consider code . key concept code possibly like set breakpoint separated server (shinybreakpoint::shinybreakpointServer() necessary need use server, used appServer well). app built modules, separation achieved definition, , shinybreakpoint needs additional step.","code":"library(shiny)  ui <- fluidPage(    )  appServer <- function(input, output, session) {   # here will be the code which will be run in the   # 'server', not in the 'server' itself }  server <- function(input, output, session) {   appServer(input, output, session)   shinybreakpoint::shinybreakpointServer() }  shinyApp(ui, server) library(shiny) library(magrittr)  ui <- fluidPage(   numericInput(\"num1\", \"Num\", 1),   numericInput(\"num2\", \"Num\", 2),   actionButton(\"go\", \"Go\") )  appServer <- function(input, output, session) {   observe({     input$num1   })      observe({     input$num2   }) %>%      bindEvent(input$go) }  server <- function(input, output, session) {   appServer(input, output, session)   shinybreakpoint::shinybreakpointServer() }  shinyApp(ui, server)"},{"path":"https://gsmolinski.github.io/shinybreakpoint/articles/app-structure.html","id":"recommended-app-structure","dir":"Articles","previous_headings":"","what":"Recommended App Structure","title":"App Structure","text":"Duplicated main server part app necessary one like set brekapoint main server, shinybreakpoint, shiny module, developed Bootstrap 5 mind, means expected appearance module noticeable bslib::bs_theme(5) set theme - code sets Bootstrap version 5 app. second version shinybreakpoint brought also new functionality - filtering displayed source code Id - Id intput output element (, reader can find article Filtering Id). Filtering based reactlog able use , needed set appropriate option. enabling reactlog, also setting additional function responsible manage temporary files, thus needed use shinybreakpoint::set_filtering_by_id(), just e.g. options(shiny.reactlog = TRUE). snipped shows recommended structure app - changes concerns main app file. code snippet, two TODOs included reminder remove calls app send production.","code":"library(shiny)      shinybreakpoint::set_filtering_by_id() # TODO: remove      ui <- fluidPage(       theme = bslib::bs_theme(5),     )      appServer <- function(input, output, session) {       # here will be the code which will be run in the       # 'server', not in the 'server' itself     }      server <- function(input, output, session) {       appServer(input, output, session)       shinybreakpoint::shinybreakpointServer() # TODO: remove     }      shinyApp(ui, server)"},{"path":"https://gsmolinski.github.io/shinybreakpoint/articles/app-structure.html","id":"setting-breakpoint","dir":"Articles","previous_headings":"","what":"Setting breakpoint","title":"App Structure","text":"run examples , one save file code, run app press F4 (key used default, check parameters running ?shinybreakpoint::shinybreakpointServer console) - modal dialog pop . example two numeric inputs one button UI well two observes (one eager - run immediately one run button pushed) server. observes visible modal dialog breakpoint can set two lines: input$num1 input$num2 possibilities won’t work. Generally can say breakpoint won’t set edges visible code blocks. Immediately breakpoint set (.e. red filled circle button () modal dialog pushed), session refreshed. means breakpoint example set input$num1 line, debug mode open immediately, set input$num2, Go button needs pushed. fact strictly depends reactive programming - debug mode opens code block (breakpoint set) starts chosen line achieved.","code":""},{"path":"https://gsmolinski.github.io/shinybreakpoint/articles/app-structure.html","id":"displaying-source-code","dir":"Articles","previous_headings":"","what":"Displaying source code","title":"App Structure","text":"shinybreakpoint tries find display objects belong reactive context (observes, reactives render*s), however guaranteed objects find objects find. , one remember shinybreakpoint designed work objects belong reactive context thus can lead errors using objects. also crucial note reactive context displayed body (context) inside curly ({}) brackets, .e. reactive({iris}) use instead reactive(iris). - course, one like set breakpoint inside reactive context, space , .e. example code look like (body function separate line): element reactive context must also inside server part (main app module). Theoretically possible include reactive context (e.g. observe()) outside server part (course outside UI part) one like share something Shiny sessions, shinybreakpoint currently won’t display code.","code":"r_iris <- reactive({   iris })"},{"path":"https://gsmolinski.github.io/shinybreakpoint/articles/app-structure.html","id":"additional-comments","dir":"Articles","previous_headings":"","what":"Additional Comments","title":"App Structure","text":"previously mentioned possibly important remarks : debugging performed original file, temporary copy file breakpoint designed one-time breakpoint means breakpoint persist one breakpoint can set one time browser() code added, srcref attribute function lost. However, shouldn’t problem since attribute used get information source object therefore useful debugging session reload twice - first time breakpoint set second one debug mode closed using c f. can inconvenient heavy computations performed session starts one uses RStudio IDE, shinybreakpoint recognizes file opened source editor file used Shiny app contains reactive blocks code, opened default file modal dialog. works moment key specified keyEvent parameter pressed","code":""},{"path":"https://gsmolinski.github.io/shinybreakpoint/articles/debugging.html","id":"reference-to-the-file","dir":"Articles","previous_headings":"","what":"Reference to the file","title":"Debugging","text":"file source()d parse()d, srcref attribute added functions indicate objects originated1. attribute contains code (chosen object) shown file, e.g. comments, also path file. Knowing , possible show user location (file, just body function) computation stops. Unfortunately, body function modified, attribute lost. now distinguish srcref attribute function body() function say attr(fun, \"srcref\") lost, attr(body(fun), \"srcref\"), won’t help us much - still won’t able point original file debug mode starts. solutions course possible show ‘stop’ location file - RStudio displays original file (browser() visible), shinybreakpoint constructs temporary file (temporary location exists long R session - confuse Shiny session) whole added code visible, separated two lines comments - first one indicates additional code starts second one reminds temporary file. Temporary file constructed breakpoint. separate file downsides, course, hand allows modify (temporary) file without fear accompany user working original file. Debug mode just mode read values, possibility execute code convenient way experiment different solutions.","code":""},{"path":"https://gsmolinski.github.io/shinybreakpoint/articles/debugging.html","id":"stepping-through-the-code","dir":"Articles","previous_headings":"","what":"Stepping through the code","title":"Debugging","text":"One way execute code debug mode just type code console move cursor one place another file (copy line execute directly editor Ctrl + Enter shortcut). Another way use shortcuts available debug mode (see ?browser) - like n go next line use panel RStudio buttons dedicated debug mode. context shinybreakpoint two things highlighted. First one exit debug mode without stopping app, c f used - c preferred, f used, RStudio still displays debug mode panels even longer debug mode app runs usual. second one debugging regular functions. Currently shinybreakpoint allows set breakpoint reactive context, doesn’t mean regular functions can’t debugging. , breakpoint set reactive context just function call debug mode option step function call (s dedicated button panel).","code":""},{"path":"https://gsmolinski.github.io/shinybreakpoint/articles/debugging.html","id":"displaying-values","dir":"Articles","previous_headings":"","what":"Displaying values","title":"Debugging","text":"Generally, R value can displayed two ways: using print(var) just typing var console (var variable). n, s shortcuts available debug mode valid variable names, can happen indeed variables names like shortcuts - situation needed use print() display value. However, can also case value won’t displayed, matter method used. case Shiny applications, happens debugging renderPrint, output captured web browser. able display values, necessary call sink() debug mode values can displayed. exiting debug mode, session refreshed, negative consequence using sink().","code":""},{"path":"https://gsmolinski.github.io/shinybreakpoint/articles/debugging.html","id":"one-time-breapoint","dir":"Articles","previous_headings":"","what":"One-time breapoint","title":"Debugging","text":"shinybreakpoint allows set one breakpoint - case breakpoints set, last one saved. Additionally, breakpoint removed exit debug mode - necessary, otherwise end infinite loop breakpoint set reactive context run app (session) starts - ’s session refreshed exiting debug mode. , however, example behavior led situation breakpoint seems persist. web browsers (breakpoint hit) app freezes (loading state), always case - sometimes UI still available. , input change (trigger reactive context breakpoint set ), user end debug mode closing . avoid , UI shouldn’t used debug mode.","code":""},{"path":"https://gsmolinski.github.io/shinybreakpoint/articles/filtering-by-id.html","id":"motivation","dir":"Articles","previous_headings":"","what":"Motivation","title":"Filtering by Id","text":"First (0.0.1) version shinybreakpoint treated code words segregated R files, specific situations source code can read way book - e.g. function definition makes necessary jump one line another find body function. Reactive programming makes even necessary jump time blocks reactive context (may exist different files) - relevant code often far away , code blocks connected outputs looking . course problematic less know (remember) code structure app. problem complicated app structure (complicated app fact developed using reactive programming) found answer reactlog package, possible see graph connected inputs, outputs reactive elements (reactives, observes) possible retrieve information. shinybreakpoint base provide possibility display source code (reactive context) relevant (connected ) given Id, Id input output Id.","code":""},{"path":"https://gsmolinski.github.io/shinybreakpoint/articles/filtering-by-id.html","id":"filtering","dir":"Articles","previous_headings":"","what":"Filtering","title":"Filtering by Id","text":"right red filled circle button (), set three small buttons displayed first one () active time - button responsible display source code standard way (files). two active Id present use filtering.","code":""},{"path":"https://gsmolinski.github.io/shinybreakpoint/articles/filtering-by-id.html","id":"last-changed-input","dir":"Articles","previous_headings":"Filtering","what":"Last changed input","title":"Filtering by Id","text":"second button () can use immediately input app changed1 input connected reactive context. input can change due user action, change can also result code running server part (like usage update* function observe). mode can search (automatically) relevant source code - may already obvious - input Id.","code":""},{"path":"https://gsmolinski.github.io/shinybreakpoint/articles/filtering-by-id.html","id":"chosen-id","dir":"Articles","previous_headings":"Filtering","what":"Chosen Id","title":"Filtering by Id","text":"Finally, third button () responsible display source code relevant previously chosen Id. Choosing performed holding Ctrl PC Cmd Mac hovering input output element - case, similar last changed input, Id saved connected reactive context. Visually, indicator displayed cursor type progress moment. mode makes possible choose input output element.","code":""},{"path":"https://gsmolinski.github.io/shinybreakpoint/articles/filtering-by-id.html","id":"requirements","dir":"Articles","previous_headings":"","what":"Requirements","title":"Filtering by Id","text":"Filtering mode can’t display lines source code standard mode, can display less lines code reality belongs Id. reminder first point, noted body reactive context must (’s also requirement standard mode) inside curly ({}) brackets found shinybreakpoint well body separate line (space set breakpoint), e.g. additionaly (also reminder described article App structure), reactive context must inside server part main app server part module (theory - .e. shiny allows - can outside server UI, shinybreakpoint won’t find code blocks). Thinking requirements specific just filtering Id, must said along limitations linked shinybreakpoint, consequence using reactlog / shiny::bindEvent(). latter can spot situations source reference object keep situations - second situation course problematic, don’t easy access name file line reactive context exists. Source reference (srcref attribute) keep : curly brackets used body reactive context observe() (observeEvent()) used, matter code block curly brackets ({}) shiny::bindEvent() used, matter observe, reactive render* object2 Luckily, can use label parameter answer inconveniences. label parameter exists observe() (observeEvent()), reactive() (eventReactive()) bindEvent(). Now - shinybreakpoint reads source code retrieve labels along information line file, label found. However, process successful : argument passed label parameter just string (.e. variable, string inside function call etc.) argument passed label parameter unique across labels Ids (.e. think label Id must unique) , time, bindEvent() used render* function, label must Id3. Examples: summarize: observe(), observeEvent() bindEvent() used (even reactive()), string must passed directly label parameter string can’t labels Ids (across whole app!) except bindEvent() used render* object, string passed argument label parameter must output Id. Please keep mind one main ideas modules shiny build construct separate namespace inside app, one remember trying apply rules bindEvent() used render* function: can see Id (iris) necessary add my_mod-, NS() returns function add prefix Id prefix id - added: NS() function factory (makes functions); passing specific argument NS() binds ns name, making ns() function - ns() function returns id passed NS(), - sign Id passed ns() function - everything pasted together. Full app example like :","code":"r_iris <- reactive({   iris }) library(shiny) library(magrittr)  server <- function(input, output, session) {   iris_r <- reactive({     iris   }) %>%      bindEvent(label = \"iris data\")      show_table <- renderTable({     iris_r()   }) %>%      bindEvent(label = \"show_table\")         cars_r <- reactive({     cars   })      observe({     invalidateLater(10000)     saveRDS(cars_r(), \"file_saved_every_10_sec.rds\")   }, label = \"save cars dataset\")    } # let's say `id` will be 'my_mod' irisUI <- function(id) {   ns <- NS(id)   tagList(     actionButton(ns(\"show\"), \"Show iris\")     tableOutput(ns(\"iris\"))   ) }  irisServer <- function(id) {   moduleServer(     id,     function(input, output, session) {       iris <- renderTable({         iris       }) %>%          bindEvent(input$show, label = \"my_mod-iris\")     }   ) } library(shiny) library(magrittr)  shinybreakpoint::set_filtering_by_id() # TODO: remove  ui <- fluidPage(   theme = bslib::bs_theme(5),   irisUI(\"my_mod\") # module UI used )  appServer <- function(input, output, session) {        }  server <- function(input, output, session) {   appServer(input, output, session)   irisServer(\"my_mod\") # module server used   shinybreakpoint::shinybreakpointServer() # TODO: remove }      shinyApp(ui, server) irisUI <- function(id) {   ns <- NS(id)   tagList(     actionButton(ns(\"show\"), \"Show iris\")     tableOutput(ns(\"iris\"))   ) }  irisServer <- function(id) {   moduleServer(     id,     function(input, output, session) {       iris <- renderTable({         iris       }) %>%          bindEvent(input$show, label = \"my_mod-iris\", ignoreInit = TRUE)     }   ) }"},{"path":"https://gsmolinski.github.io/shinybreakpoint/articles/filtering-by-id.html","id":"keeping-reactlog-clean","dir":"Articles","previous_headings":"","what":"Keeping reactlog clean","title":"Filtering by Id","text":"shinybreakpoint::set_filtering_by_id() enables reactlog, also app stops, removes reactlog data temporary directory. negative result manipulating functions attributes shinybreakpoint - reactlog data can’t just recreate app running, app starts, otherwise Id dependency won’t find correctly. two consequences - first one one want change something source code app, app stopped run - however shouldn’t big inconvenience since also necessary source code module modified shinybreakpoint created modules mind. second consequence reason app stopped debug mode, .e. Q used debug mode, reactlog data won’t cleaned properly. Unfortunately, means use filtering Id, Q option debug mode can’t use - one like exit debug mode app, possible return app (f c debug mode) stopping app.","code":""},{"path":[]},{"path":"https://gsmolinski.github.io/shinybreakpoint/articles/what-about-trace.html","id":"the-myth","dir":"Articles","previous_headings":"I. The Story","what":"The Myth","title":"","text":"talk given 2016 Shiny Developer Conference, Jonathan McPherson noticed: ’re seasoned R programmer, may used trace() function add tracing without modifying script. Unfortunately, ’s possible use utility (depend , setBreakpoint) Shiny. trace() works rewriting body function traced, function must already exist run . Shiny generates functions runtime aren’t easily addressable. fragment titled “trace()?” now available official documentation Shiny1. say somehow suspicious, since paragraph said something impossible, thing easily addressable, - expect - impossible addressable. ’s good paragraph start , even saying everything started, suspicion, nothing founding myth.","code":""},{"path":"https://gsmolinski.github.io/shinybreakpoint/articles/what-about-trace.html","id":"where-are-you-objects","dir":"Articles","previous_headings":"I. The Story","what":"Where Are You, Objects?","title":"","text":"aim modification body function insert browser() , first need find functions. can using lapply(rlang::env_parents(rlang::current_env()), names) example : app.R R/mod.R code iterates environments, starting current environment, move parent environments, displaying objects environments well. running , learn structure objects Shiny app following characteristic: top (: parent) global environment, example doesn’t contain objects created us next, going top bottom (.e. first child) find objects module (saved R/mod.R file) - UI server part (named modUI modServer) finally, grandchild see objects file started - server ui app.R file (can ignore rest objects environments) environments named (like global environment) Graphically structure looks like : , course, evidence documentation right: R code Shiny app run global environment child it2 Now, able find objects (search precise - also get environments objects live), can try modify .","code":"library(shiny)  ui <- fluidPage(   modUI(\"mod\"),   textOutput(\"env\") )  server <- function(input, output, session) {   modServer(\"mod\")      output$env <- renderPrint({     lapply(rlang::env_parents(rlang::current_env()), names)   }) }  shinyApp(ui, server) modUI <- function(id) {   ns <- NS(id)   tagList(     numericInput(ns(\"num\"), \"Num\", 0)   ) }  modServer <- function(id) {   moduleServer(     id,     function(input, output, session) {     }   ) } \"global\": .Random.seed   └── \"\": modServer, modUI       └── \"\": server, ui           └── \"\": input, output, session                                       and so on..."},{"path":"https://gsmolinski.github.io/shinybreakpoint/articles/what-about-trace.html","id":"and-where-are-your-elements","dir":"Articles","previous_headings":"I. The Story","what":"And Where Are Your Elements?","title":"","text":"want modify body function use body() . trying precise, just useful purposes, can say body() returns complex list (although type list, language). list can manipulated - elements can added, removed etc. just need additional functions , like .list() (can use append() add elements list), .call() (turn back list language object) quote() evaluate browser(): now breakpoint set first element body (first element bracket). Let’s complete Shiny app: app.R R/mod.R can notice Add browser button pushed, nothing happens. However, true - browser() added, didn’t yet run function. words, added browser() used yet. can use another example show clearly: know browser() really works? ’s tricky question, suggests can know something run actually running . Instead trying answer , let’s just run function: fun1(). end debug mode. can achieve effect Shiny app refreshing session - hand, clicking refresh button web browser adding getDefaultReactiveDomain()$reload() reload session (.e. using reload() method session object, also session$reload()): app.R , re-run modServer() function.","code":"server <- function(input, output) {   shiny::observe({     x <- 2     x   }) }  body(server) #> { #>     shiny::observe({ #>         x <- 2 #>         x #>     }) #> }  body(server)[[2]][[2]][[2]] #> x <- 2  body(server)[[2]][[2]][[2]][[1]] #> `<-` server <- function(input, output) {   shiny::observe({     x <- 2     x   }) }  body(server)[[c(2, 2)]] #> { #>     x <- 2 #>     x #> }  body(server)[[c(2, 2)]] <- as.call(append(as.list(body(server)[[c(2, 2)]]), quote(browser()), 1)) body(server)[[c(2, 2)]] #> { #>     browser() #>     x <- 2 #>     x #> } library(shiny) library(magrittr)  ui <- fluidPage(   modUI(\"mod\"),   textOutput(\"env\"),   actionButton(\"browser\", \"Add browser\") )  server <- function(input, output, session) {   modServer(\"mod\")      output$env <- renderPrint({     mod_env <- environment(modServer) # get the environment where `modServer` is defined     as.list(body(mod_env$modServer)[[2]][[3]][[3]][[2]][[2]])   })      observe({     mod_env <- environment(modServer)     body(mod_env$modServer)[[2]][[3]][[3]][[2]][[2]] <- as.call(append(as.list(body(mod_env$modServer)[[2]][[3]][[3]][[2]][[2]]), quote(browser()), 1))   }) %>%      bindEvent(input$browser) }  shinyApp(ui, server) modUI <- function(id) {   ns <- NS(id)   tagList(     numericInput(ns(\"num\"), \"Num\", 0)   ) }  modServer <- function(id) {   moduleServer(     id,     function(input, output, session) {       observe({         input$num       })     }   ) } fun1 <- function() {   x <- 2   x }  body(fun1) <- as.call(append(as.list(body(fun1)), quote(browser()), 2)) body(fun1) #> { #>     x <- 2 #>     browser() #>     x #> } library(shiny) library(magrittr)  ui <- fluidPage(   modUI(\"mod\"),   textOutput(\"env\"),   actionButton(\"browser\", \"Add browser\") )  server <- function(input, output, session) {   modServer(\"mod\")      output$env <- renderPrint({     mod_env <- environment(modServer)     as.list(body(mod_env$modServer)[[2]][[3]][[3]][[2]][[2]])   })      observe({     mod_env <- environment(modServer)     body(mod_env$modServer)[[2]][[3]][[3]][[2]][[2]] <- as.call(append(as.list(body(mod_env$modServer)[[2]][[3]][[3]][[2]][[2]]), quote(browser()), 1))     getDefaultReactiveDomain()$reload() # added   }) %>%      bindEvent(input$browser) }  shinyApp(ui, server)"},{"path":"https://gsmolinski.github.io/shinybreakpoint/articles/what-about-trace.html","id":"find-them-again-and-again","dir":"Articles","previous_headings":"I. The Story","what":"Find Them Again (And Again)","title":"","text":"Among (yet mentioned) problems, still need tools find insert browser(), now just used eyes. somehow secondary issue mainly like show vignette core concept setting breakpoint, even hand, solutions rather signaled. (named) function, saved file (source()d, srcref attribute present), can use following functions: utils::getParseData() get data.frame needed reconstruct whole script saved file (utils::getParseText() can useful context well) utils::getSrcFilename() get name file utils::findLineNum() get (1) name object; (2) environment object lives; (3) location body object based line number script (.e. indices use get right location using body()[[]]) However, quickly find modifying body function, broke - utils::findLineNum() longer returns correct indices (element returned list broken): app.R R/mod.R example , display element returned list - Add browser button pushed first time (debug mode closed pressing c f), can see displayed indices changed longer can use element find correct location body function. words, code now works just one time - first use, app closed run (use determine location body, course; example still using hard-coded location). resolve problem, need retrieve original body object (function) - one way use parse(). already know name file (full path well) comes function, possible parse file assign original body function broken one, browser() added.","code":"library(shiny) library(magrittr)  ui <- fluidPage(   modUI(\"mod\"),   textOutput(\"env\"),   actionButton(\"browser\", \"Add browser\") )  server <- function(input, output, session) {   modServer(\"mod\")      output$env <- renderPrint({     findLineNum(\"R/mod.R\", 13)[[1]]$at # check how this changed after the first use of button 'Add browser'   })      observe({     mod_env <- environment(modServer)     body(mod_env$modServer)[[2]][[3]][[3]][[2]][[2]] <- as.call(append(as.list(body(mod_env$modServer)[[2]][[3]][[3]][[2]][[2]]), quote(browser()), 1))     getDefaultReactiveDomain()$reload()   }) %>%      bindEvent(input$browser) }  shinyApp(ui, server) modUI <- function(id) {   ns <- NS(id)   tagList(     numericInput(ns(\"num\"), \"Num\", 0)   ) }  modServer <- function(id) {   moduleServer(     id,     function(input, output, session) {       observe({         input$num       })     }   ) }"},{"path":"https://gsmolinski.github.io/shinybreakpoint/articles/what-about-trace.html","id":"and-forget-them","dir":"Articles","previous_headings":"I. The Story","what":"And Forget Them","title":"","text":"actions taken now led us state greed; find objects, modify never undo changes; modify , , adding browser()s. can seen previous example - time Add browser button pushed, next browser() added top previous one. Now greed leads us trouble: need escape (using c f) debug mode multiple times escape real - browser() nests us debug mode much worse - browser() persists time observe() runs (runs every time input$num changes), end debug mode remedy remove browser() use, .e. pressing c f (closing) debug mode. must done within function debugged (session reload). words, function remove elements. exemplification mechanism: can see include code removes ; code can added function using function well (example just added beginning, hand). case Shiny app, need remember another session reload necessary equivalent function call (equivalent fun2()). example Shiny app one-time breakpoint. app.R R/mod.R example looks quite complex now, may useful describe (even repeating something) crucial steps: mod_env <- environment(modServer) - just getting environment modServer() function defined - later explained, use body(mod_env$modServer)[[2]][[3]][[3]][[2]][[2]] <- .call(append(.list(body(mod_env$modServer)[[2]][[3]][[3]][[2]][[2]]), quote(browser()), 1)) - browser added body(mod_env$modServer)[[2]][[3]][[3]][[2]][[2]] <- .call(append(.list(body(mod_env$modServer)[[2]][[3]][[3]][[2]][[2]]), quote(env <- environment(modServer)), 2)) - function adding code responsible get environment function defined (.e. function setting breakpoint) body(mod_env$modServer)[[2]][[3]][[3]][[2]][[2]] <- .call(append(.list(body(mod_env$modServer)[[2]][[3]][[3]][[2]][[2]]), quote(body(env$modServer)[[2]][[3]][[3]][[2]][[2]] <- body(env$modServer)[[2]][[3]][[3]][[2]][[2]][-c(2, 3, 4, 5)]), 3)) - adding function code responsible remove added code function body(mod_env$modServer)[[2]][[3]][[3]][[2]][[2]] <- .call(append(.list(body(mod_env$modServer)[[2]][[3]][[3]][[2]][[2]]), quote(getDefaultReactiveDomain()$reload()), 4)) - adding session reload function (session refreshed closing debug mode) getDefaultReactiveDomain()$reload() - reloading session (breakpoint set) interesting useful thing line code can remove next line code, time next line code can still executed - using reload session added code removed remove code responsible reload. Perhaps clearer see , taking example regular function: run function fun2 first time, last element (string \"two\"), removing, returned, run first time, function execute lines code, can check body changed run function , number 2 returned. important, means can add session reload function session reload run (changes can applied) removed function. noted , even looks like retrieving original body function (added elements removed), answer (mentioned earlier) problem element list returned utils::findLineNum() function - still contain wrong indices.","code":"fun2 <- function() {   2   env <- environment(fun2) # get the environment where `fun2` is defined   body(env$fun2) <- body(env$fun2)[-c(3, 4)] }  body(fun2) #> { #>     2 #>     env <- environment(fun2) #>     body(env$fun2) <- body(env$fun2)[-c(3, 4)] #> }  fun2()  body(fun2) #> { #>     2 #> } library(shiny) library(magrittr)  ui <- fluidPage(   modUI(\"mod\"),   actionButton(\"browser\", \"Add browser\"), )  server <- function(input, output, session) {   modServer(\"mod\")      observe({     mod_env <- environment(modServer)     body(mod_env$modServer)[[2]][[3]][[3]][[2]][[2]] <- as.call(append(as.list(body(mod_env$modServer)[[2]][[3]][[3]][[2]][[2]]), quote(browser()), 1))     body(mod_env$modServer)[[2]][[3]][[3]][[2]][[2]] <- as.call(append(as.list(body(mod_env$modServer)[[2]][[3]][[3]][[2]][[2]]), quote(env <- environment(modServer)), 2))     body(mod_env$modServer)[[2]][[3]][[3]][[2]][[2]] <- as.call(append(as.list(body(mod_env$modServer)[[2]][[3]][[3]][[2]][[2]]), quote(body(env$modServer)[[2]][[3]][[3]][[2]][[2]] <- body(env$modServer)[[2]][[3]][[3]][[2]][[2]][-c(2, 3, 4, 5)]), 3))     body(mod_env$modServer)[[2]][[3]][[3]][[2]][[2]] <- as.call(append(as.list(body(mod_env$modServer)[[2]][[3]][[3]][[2]][[2]]), quote(getDefaultReactiveDomain()$reload()), 4))     getDefaultReactiveDomain()$reload()   }) %>%      bindEvent(input$browser) }  shinyApp(ui, server) modUI <- function(id) {   ns <- NS(id)   tagList(     numericInput(ns(\"num\"), \"Num\", 0)   ) }  modServer <- function(id) {   moduleServer(     id,     function(input, output, session) {       observe({         input$num       })     }   ) } fun2 <- function() {   2   env <- environment(fun2)   body(env$fun2) <- body(env$fun2)[-c(3, 4, 5)]   \"two\" }  body(fun2) #> { #>     2 #>     env <- environment(fun2) #>     body(env$fun2) <- body(env$fun2)[-c(3, 4, 5)] #>     \"two\" #> }  fun2() #> [1] \"two\"  body(fun2) #> { #>     2 #> }"},{"path":"https://gsmolinski.github.io/shinybreakpoint/articles/what-about-trace.html","id":"where-are-you-objects-1","dir":"Articles","previous_headings":"I. The Story","what":"“Where Are You, Objects?”","title":"","text":"one last thing talk - getting (right) environment. examples Shiny app presented now, used environment() get environment object (function), also example regular function remove (within function) elements function. examples personify two aspects important us- necessary get environment object defined necessary precise. code help us answer, need environment: stop thinking problem terms self-referencing, looks simple - can’t modify object defined parent child environment, isolation (function closures environment), however can explicitly refer environment object defined. Now just need remind function defined different environment environment exist function’s elements- defined parent environment. Thus modify function (function) need refer explicitly environment function defined - different example variable . answer, needed refer environment inside function, needed also observe beginning, set breakpoint? one hand, indeed unnecessary - easily refer object directly, (hand) safe - functions name, different environments? refer function, function? environment() returns environment nearest function may enough purposes. see three functions, name live different environment. already know function want refer upper environment (inside function), sure direct parent, can end reference wrong object, - already said - environment() gives us environment nearest object chosen name. previous examples used environment(), just simplicity - see now wasn’t great idea. shinybreakpoint uses something different - function searches environments get needed environment. able refer precise given function, needed know environment. Relatively easy connect object environment upfront, searching objects across environments using code mentioned beginning, .e. lapply(rlang::env_parents(rlang::current_env()), names). first use rlang::env_parents(rlang::current_env()) get list environments get objects list, using lapply() names(). way two lists length every element point environment, problem occur trying use environment code added along browser(). Coming back Shiny app, used line code : constructing env variable environment, know environment contains modServer looking function name, different environment (like showed )? know possible list environments objects (functions) belong given environment, use knowledge? solution won’t work: constructed call (assignment), using variable env environment fun3 defined, call correct - see impossible treat environment like regular value - can’t simply evaluate variable get value. idea bad - already object (fun3) environment (env), just add body function code bind environment name envir. way correct environment refer , see, instead get something like assign(\"envir\", .GlobalEnv), incorrect syntax: assign(\"envir\", <environment>). can, however, keep label environment need search correct environment using label. Label name environment (named) address memory - get label, use rlang::env_label(). expression assign(\"envir\", get_envir(\"global\")) can now added along browser() get right environment - know (example ) \"global\" environment search (function get_envir()) give us precise environment - labels unique. course, still think make sure get_envir() visible environment (function) code added. case Shiny app can stored global environment (objects global environment visible environment app, top environment). case shinybreakpoint, function lives {shnybreakpoint} environment (namespace), access function problem well (package installed).","code":"a <- 4 fun2 <- function() {   a <- 2 } fun2() a #> [1] 4  a <- 4 fun2 <- function() {   env <- .GlobalEnv   env$a <- 2 } fun2() a #> [1] 2 env_inner <- \"\" env_outer <- \"\"  fun3 <- function() {   fun3 <- function() {     fun3 <- function() {       env_inner <<- environment(fun3)     }     fun3()   }   fun3()   env_outer <<- environment(fun3) }  fun3()  env_inner #> <environment: 0x0000000022e49560>  env_outer #> <environment: 0x0000000022e49678> body(mod_env$modServer)[[2]][[3]][[3]][[2]][[2]] <- as.call(append(as.list(body(mod_env$modServer)[[2]][[3]][[3]][[2]][[2]]), quote(env <- environment(modServer)), 2)) fun3 <- function() {   3 } env <- environment(fun3) # global environment call(\"assign\", \"envir\", env) #> assign(\"envir\", <environment>)  # assign(\"envir\", <environment>) # Error: unexpected '<' in \"assign(\"envir\", <\" fun3 <- function() {   3 } env_lab <- rlang::env_label(environment(fun3))  get_envir <- function(label) {   envirs <- rlang::env_parents(rlang::current_env())   names(envirs) <- lapply(envirs, rlang::env_label)   envirs[[label]] }  call(\"assign\", \"envir\", call(\"get_envir\", env_lab)) #> assign(\"envir\", get_envir(\"global\"))"},{"path":"https://gsmolinski.github.io/shinybreakpoint/articles/what-about-trace.html","id":"ii--closure","dir":"Articles","previous_headings":"","what":"II. Closure","title":"","text":"Setting breakpoint technique based source code understanding commands executed line--line. source code visible humans - stored like text used read text knowing next statement left, right, . Functions make little complicated - function definition can far, far away line function called, know, received results see, may necessary jump different place file check function body (set breakpoint). Reactive programming makes even complicated - easy know, code block executed input changed. idea storing functions, grouped functions modules separate files try give source code intuitive structure point difference text story text code becomes tangible. even start thinking affinity code text ballast. Isn’t true split source code multiple files want able read text (story) easily possible fragmented text (story)? don’t feel setting breakpoint now selecting text fragment book even writing reading book? course, someone say can use digital tools search text fragment source code book, one important difference story code - story executed brains, code . really need expose source code written text, line? even smaller file - still need always see characters? last chapter summary, idea perhaps useful display source code, relations code blocks belong reactive context minimize exposition developer text far possible; using fact code executed machine, brain, useful display last relation, breakpoint can set somewhere chain relevant output side effect. course new, still matter future, reminded document.","code":""},{"path":"https://gsmolinski.github.io/shinybreakpoint/authors.html","id":null,"dir":"","previous_headings":"","what":"Authors","title":"Authors and Citation","text":"Grzegorz Smoliński. Author, maintainer.","code":""},{"path":"https://gsmolinski.github.io/shinybreakpoint/authors.html","id":"citation","dir":"","previous_headings":"","what":"Citation","title":"Authors and Citation","text":"Smoliński G (2022). shinybreakpoint: Set Breakpoint 'Shiny'. https://gsmolinski.github.io/shinybreakpoint/, https://github.com/gsmolinski/shinybreakpoint,.","code":"@Manual{,   title = {shinybreakpoint: Set Breakpoint in 'Shiny'},   author = {Grzegorz Smoliński},   year = {2022},   note = {https://gsmolinski.github.io/shinybreakpoint/, https://github.com/gsmolinski/shinybreakpoint,}, }"},{"path":[]},{"path":"https://gsmolinski.github.io/shinybreakpoint/index.html","id":"description","dir":"","previous_headings":"shinybreakpoint","what":"Description","title":"Set Breakpoint in Shiny","text":"shinybreakpoint shiny module one can add Shiny application. answer problem setting (editor) breakpoint modules stored separate files - currently possible RStudio IDE. shinybreakpoint breakpoint can set reactive context file making developing modularized Shiny applications easier.","code":""},{"path":"https://gsmolinski.github.io/shinybreakpoint/index.html","id":"installation","dir":"","previous_headings":"shinybreakpoint","what":"Installation","title":"Set Breakpoint in Shiny","text":"can install development version shinybreakpoint GitHub :","code":"# install.packages(\"devtools\") devtools::install_github(\"gsmolinski/shinybreakpoint\")"},{"path":"https://gsmolinski.github.io/shinybreakpoint/index.html","id":"documentation","dir":"","previous_headings":"shinybreakpoint","what":"Documentation","title":"Set Breakpoint in Shiny","text":"See whole documentation Articles section.","code":""},{"path":"https://gsmolinski.github.io/shinybreakpoint/reference/set_filtering_by_id.html","id":null,"dir":"Reference","previous_headings":"","what":"Set Option to Filtering by Id — set_filtering_by_id","title":"Set Option to Filtering by Id — set_filtering_by_id","text":"Enable reactlog functionality remove data saved temporary directory app stops.","code":""},{"path":"https://gsmolinski.github.io/shinybreakpoint/reference/set_filtering_by_id.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Set Option to Filtering by Id — set_filtering_by_id","text":"","code":"set_filtering_by_id()"},{"path":"https://gsmolinski.github.io/shinybreakpoint/reference/set_filtering_by_id.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Set Option to Filtering by Id — set_filtering_by_id","text":"Used side effect - enable reactlog set cleaning temporary directory.","code":""},{"path":"https://gsmolinski.github.io/shinybreakpoint/reference/set_filtering_by_id.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Set Option to Filtering by Id — set_filtering_by_id","text":"function must used outside server part app.","code":""},{"path":"https://gsmolinski.github.io/shinybreakpoint/reference/set_filtering_by_id.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Set Option to Filtering by Id — set_filtering_by_id","text":"","code":"if (FALSE) {  library(shiny)  shinybreakpoint::set_filtering_by_id() # TODO: remove  appServer <- function(input, output, session) {   observe({     input$num   }, label = \"observe_print_num_input\") }  shinyApp(   ui = fluidPage(     theme = bslib::bs_theme(5),     numericInput(\"num\", \"Num\", 0)   ),   server = function(input, output, session) {     shinybreakpoint::shinybreakpointServer() # TODO: remove     appServer(input, output, session)   } ) }"},{"path":"https://gsmolinski.github.io/shinybreakpoint/reference/shinybreakpointServer.html","id":null,"dir":"Reference","previous_headings":"","what":"Use Module to Set Breakpoint — shinybreakpointServer","title":"Use Module to Set Breakpoint — shinybreakpointServer","text":"Module Shiny app needed enable functionality setting breakpoint. Must used server part Shiny app function used server part app.","code":""},{"path":"https://gsmolinski.github.io/shinybreakpoint/reference/shinybreakpointServer.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Use Module to Set Breakpoint — shinybreakpointServer","text":"","code":"shinybreakpointServer(   keyEvent = \"F4\",   id = \"shinybreakpoint\",   varName = \"....envirr\" )"},{"path":"https://gsmolinski.github.io/shinybreakpoint/reference/shinybreakpointServer.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Use Module to Set Breakpoint — shinybreakpointServer","text":"keyEvent key run modal dialog functionality set breakpoint. \"F4\" default. id namespace used inputs outputs module. \"shinybreakpoint\" default. Change app module used already \"shinybreakpoint\" namespace. varName setting breakpoint equal inserting browser(), also additional code, one assignment operation. parameter determines variable name assign value. \"....envirr\" default. Change name already use somewhere app.","code":""},{"path":"https://gsmolinski.github.io/shinybreakpoint/reference/shinybreakpointServer.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Use Module to Set Breakpoint — shinybreakpointServer","text":"Used side effect - adds modal dialog Shiny app options set breakpoint. Modal dialog shown key specified keyEvent pressed.","code":""},{"path":"https://gsmolinski.github.io/shinybreakpoint/reference/shinybreakpointServer.html","id":"app-structure","dir":"Reference","previous_headings":"","what":"App structure","title":"Use Module to Set Breakpoint — shinybreakpointServer","text":"One core concepts founds module necessity re-run objects present server part app. possible objects live directly server, function used server. naturally harmonizes modules, needs separate function objects used directly server. shinybreakpointServer module developed Bootstrap 5 mind, recommended use bslib::bs_theme() set Bootstrap 5. Otherwise UI experience worse. Possibility filter reactive context depending specific input output needs shiny::reactlog() enabled, done set_filtering_by_id(). line code needs removed app sent production (course true also shinybreakpoint::shinybreakpointServer() line). See example section idea include requirements app. can also done snippet() new apps.","code":""},{"path":"https://gsmolinski.github.io/shinybreakpoint/reference/shinybreakpointServer.html","id":"filtering-by-id","dir":"Reference","previous_headings":"","what":"Filtering by Id","title":"Use Module to Set Breakpoint — shinybreakpointServer","text":"long shiny::reactlog() enabled (function set_filtering_by_id(), function responsible also manage needed files temporary directory, .e. enough just use options(shiny.reactlog = TRUE) similar), possible filter displayed source code based input output Id, .e. relevant source code (reactives, observes render* functions) shown. Two modes available: Last changed input - last changed input tracked automatically, .e. nothing special needs done. Chosen Id - holding Ctrl PC Cmd Mac hovering mouse input output, Id element saved (indicated displaying cursor type 'progress' moment). successfully see relevant source code Id, necessary ensure code inside reactives, observes render* functions curly ({}) brackets observes well shiny::bindEvent() (used) label, .e. string passed directly label parameter. Label needs unique across labels Ids. Additionally, shiny::bindEvent() used render* function, label must output Id. last case Id masked shiny::bindEvent(), afraid label Id unique. Q option (exit) use debug mode properly use filtering Id. Please use c f close debug mode - return app app can stopped usual way needed.","code":""},{"path":"https://gsmolinski.github.io/shinybreakpoint/reference/shinybreakpointServer.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Use Module to Set Breakpoint — shinybreakpointServer","text":"","code":"# To run example, copy-paste to file, save # the file and run the app. Then press \"F4\" # to open the modal dialog.  if (FALSE) {  library(shiny)  shinybreakpoint::set_filtering_by_id() # TODO: remove  appServer <- function(input, output, session) {   observe({     input$num   }, label = \"observe_print_num_input\") }  shinyApp(   ui = fluidPage(     theme = bslib::bs_theme(5),     numericInput(\"num\", \"Num\", 0)   ),   server = function(input, output, session) {     shinybreakpoint::shinybreakpointServer() # TODO: remove     appServer(input, output, session)   } ) }"},{"path":"https://gsmolinski.github.io/shinybreakpoint/reference/snippet.html","id":null,"dir":"Reference","previous_headings":"","what":"Write (Append) Basic Shiny App With Shinybreakpoint Functionality — snippet","title":"Write (Append) Basic Shiny App With Shinybreakpoint Functionality — snippet","text":"Append code skeleton shinybreakpoint functionality active (opened) file RStudio.","code":""},{"path":"https://gsmolinski.github.io/shinybreakpoint/reference/snippet.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Write (Append) Basic Shiny App With Shinybreakpoint Functionality — snippet","text":"","code":"snippet()"},{"path":"https://gsmolinski.github.io/shinybreakpoint/reference/snippet.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Write (Append) Basic Shiny App With Shinybreakpoint Functionality — snippet","text":"Appends code skeleton file.","code":""},{"path":"https://gsmolinski.github.io/shinybreakpoint/reference/snippet.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Write (Append) Basic Shiny App With Shinybreakpoint Functionality — snippet","text":"shinybreakpoint needs server logic included function separated server part app, also developed Bootstrap version 5 mind functionalities needs shiny::reactlog enabled well managing temporary files (shinybreakpoint::set_filtering_by_id()) responsible . snippet takes care . Snippet also available addin, name snippet.","code":""},{"path":"https://gsmolinski.github.io/shinybreakpoint/reference/snippet.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Write (Append) Basic Shiny App With Shinybreakpoint Functionality — snippet","text":"","code":"if (FALSE) { # use shinybreakpoint::snippet() in the Console in RStudio # (or find `snippet` addin in Addins menu) # if there is an opened file (in Source Editor), # then this skeleton should be added to the file: library(shiny)  shinybreakpoint::set_filtering_by_id() # TODO: remove  ui <- fluidPage(   theme = bslib::bs_theme(5),  )  appServer <- function(input, output, session) {  }  server <- function(input, output, session) {   shinybreakpoint::shinybreakpointServer() # TODO: remove   appServer(input, output, session) }  shinyApp(ui, server) }"},{"path":"https://gsmolinski.github.io/shinybreakpoint/news/index.html","id":"shinybreakpoint-002","dir":"Changelog","previous_headings":"","what":"shinybreakpoint 0.0.2","title":"shinybreakpoint 0.0.2","text":"Filter reactive context dependencies based chosen input output.","code":""},{"path":"https://gsmolinski.github.io/shinybreakpoint/news/index.html","id":"shinybreakpoint-001","dir":"Changelog","previous_headings":"","what":"shinybreakpoint 0.0.1","title":"shinybreakpoint 0.0.1","text":"First version - display source code, set one-time breakpoint, show temporary file breakpoint, refresh session enable breakpoint quitting debug mode.","code":""}]
