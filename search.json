[{"path":"https://gsmolinski.github.io/shinybreakpoint/LICENSE.html","id":null,"dir":"","previous_headings":"","what":"MIT License","title":"MIT License","text":"Copyright (c) 2022 Grzegorz Smoliński Permission hereby granted, free charge, person obtaining copy software associated documentation files (“Software”), deal Software without restriction, including without limitation rights use, copy, modify, merge, publish, distribute, sublicense, /sell copies Software, permit persons Software furnished , subject following conditions: copyright notice permission notice shall included copies substantial portions Software. SOFTWARE PROVIDED “”, WITHOUT WARRANTY KIND, EXPRESS IMPLIED, INCLUDING LIMITED WARRANTIES MERCHANTABILITY, FITNESS PARTICULAR PURPOSE NONINFRINGEMENT. EVENT SHALL AUTHORS COPYRIGHT HOLDERS LIABLE CLAIM, DAMAGES LIABILITY, WHETHER ACTION CONTRACT, TORT OTHERWISE, ARISING , CONNECTION SOFTWARE USE DEALINGS SOFTWARE.","code":""},{"path":[]},{"path":"https://gsmolinski.github.io/shinybreakpoint/articles/background.html","id":"the-myth","dir":"Articles","previous_headings":"I. The Story","what":"The Myth","title":"","text":"talk given 2016 Shiny Developer Conference, Jonathan McPherson noticed: ’re seasoned R programmer, may used trace() function add tracing without modifying script. Unfortunately, ’s possible use utility (depend , setBreakpoint) Shiny. trace() works rewriting body function traced, function must already exist run . Shiny generates functions runtime aren’t easily addressable. fragment titled “trace()?” now available official documentation Shiny1. say somehow suspicious, since paragraph said something impossible, thing easily addressable, - expect - impossible addressable. ’s good paragraph start , even saying everything started, suspicion, nothing founding myth.","code":""},{"path":"https://gsmolinski.github.io/shinybreakpoint/articles/background.html","id":"where-are-you-objects","dir":"Articles","previous_headings":"I. The Story","what":"Where Are You, Objects?","title":"","text":"aim modification body function insert browser() , first need find functions. can using lapply(rlang::env_parents(rlang::current_env()), names) example : app.R R/mod.R code iterates environments, starting current environment, move parent environments, displaying objects environments well. running , learn structure objects Shiny app following characteristic: top (: parent) global environment, example doesn’t contain objects created us next, going top bottom (.e. first child) find objects module (saved R/mod.R file) - UI server part (named modUI modServer) finally, grandchild see objects file started - server ui app.R file (can ignore rest objects environments) environments named (like global environment) Graphically structure looks like : , course, evidence documentation right: R code Shiny app run global environment child it2 Now, able find objects (search precise - also get environments objects live), can try modify .","code":"library(shiny)  ui <- fluidPage(   modUI(\"mod\"),   textOutput(\"env\") )  server <- function(input, output, session) {   modServer(\"mod\")      output$env <- renderPrint({     lapply(rlang::env_parents(rlang::current_env()), names)   }) }  shinyApp(ui, server) modUI <- function(id) {   ns <- NS(id)   tagList(     numericInput(ns(\"num\"), \"Num\", 0)   ) }  modServer <- function(id) {   moduleServer(     id,     function(input, output, session) {     }   ) } \"global\": .Random.seed   └── \"\": modServer, modUI       └── \"\": server, ui           └── \"\": input, output, session                                       and so on..."},{"path":"https://gsmolinski.github.io/shinybreakpoint/articles/background.html","id":"and-where-are-your-elements","dir":"Articles","previous_headings":"I. The Story","what":"And Where Are Your Elements?","title":"","text":"want modify body function use body() . trying precise, just useful purposes, can say body() returns complex list (although type list, language). list can manipulated - elements can added, removed etc. just need additional functions , like .list() (can use append() add elements list), .call() (turn back list language object) quote() evaluate browser(): now breakpoint set first element body (first element bracket). Let’s complete Shiny app: app.R R/mod.R can notice Add browser button pushed, nothing happens. However, true - browser() added, didn’t yet run function. words, added browser() used yet. can use another example show clearly: know browser() really works? ’s tricky question, suggests can know something run actually running . Instead trying answer , let’s just run function: fun1(). end debug mode. can achieve effect Shiny app refreshing session - hand, clicking refresh button web browser adding getDefaultReactiveDomain()$reload() reload session (.e. using reload() method session object, also session$reload()): app.R , re-run modServer() function.","code":"server <- function(input, output) {   shiny::observe({     x <- 2     x   }) }  body(server) #> { #>     shiny::observe({ #>         x <- 2 #>         x #>     }) #> }  body(server)[[2]][[2]][[2]] #> x <- 2  body(server)[[2]][[2]][[2]][[1]] #> `<-` server <- function(input, output) {   shiny::observe({     x <- 2     x   }) }  body(server)[[c(2, 2)]] #> { #>     x <- 2 #>     x #> }  body(server)[[c(2, 2)]] <- as.call(append(as.list(body(server)[[c(2, 2)]]), quote(browser()), 1)) body(server)[[c(2, 2)]] #> { #>     browser() #>     x <- 2 #>     x #> } library(shiny) library(magrittr)  ui <- fluidPage(   modUI(\"mod\"),   textOutput(\"env\"),   actionButton(\"browser\", \"Add browser\") )  server <- function(input, output, session) {   modServer(\"mod\")      output$env <- renderPrint({     mod_env <- environment(modServer) # get the environment where `modServer` is defined     as.list(body(mod_env$modServer)[[2]][[3]][[3]][[2]][[2]])   })      observe({     mod_env <- environment(modServer)     body(mod_env$modServer)[[2]][[3]][[3]][[2]][[2]] <- as.call(append(as.list(body(mod_env$modServer)[[2]][[3]][[3]][[2]][[2]]), quote(browser()), 1))   }) %>%      bindEvent(input$browser) }  shinyApp(ui, server) modUI <- function(id) {   ns <- NS(id)   tagList(     numericInput(ns(\"num\"), \"Num\", 0)   ) }  modServer <- function(id) {   moduleServer(     id,     function(input, output, session) {       observe({         input$num       })     }   ) } fun1 <- function() {   x <- 2   x }  body(fun1) <- as.call(append(as.list(body(fun1)), quote(browser()), 2)) body(fun1) #> { #>     x <- 2 #>     browser() #>     x #> } library(shiny) library(magrittr)  ui <- fluidPage(   modUI(\"mod\"),   textOutput(\"env\"),   actionButton(\"browser\", \"Add browser\") )  server <- function(input, output, session) {   modServer(\"mod\")      output$env <- renderPrint({     mod_env <- environment(modServer)     as.list(body(mod_env$modServer)[[2]][[3]][[3]][[2]][[2]])   })      observe({     mod_env <- environment(modServer)     body(mod_env$modServer)[[2]][[3]][[3]][[2]][[2]] <- as.call(append(as.list(body(mod_env$modServer)[[2]][[3]][[3]][[2]][[2]]), quote(browser()), 1))     getDefaultReactiveDomain()$reload() # added   }) %>%      bindEvent(input$browser) }  shinyApp(ui, server)"},{"path":"https://gsmolinski.github.io/shinybreakpoint/articles/background.html","id":"find-them-again-and-again","dir":"Articles","previous_headings":"I. The Story","what":"Find Them Again (And Again)","title":"","text":"Among (yet mentioned) problems, still need tools find insert browser(), now just used eyes. somehow secondary issue mainly like show vignette core concept setting breakpoint, even hand, solutions rather signaled. (named) function, saved file (source()d, srcref attribute present), can use following functions: utils::getParseData() get data.frame needed reconstruct whole script saved file (utils::getParseText() can useful context well) utils::getSrcFilename() get name file utils::findLineNum() get (1) name object; (2) environment object lives; (3) location body object based line number script (.e. indices use get right location using body()[[]]) However, quickly find modifying body function, broke - utils::findLineNum() longer returns correct indices (element returned list broken): app.R R/mod.R example , display element returned list - Add browser button pushed first time (debug mode closed pressing c f), can see displayed indices changed longer can use element find correct location body function. words, code now works just one time - first use, app closed run (use determine location body, course; example still using hard-coded location). resolve problem, need retrieve original body object (function) - one way use parse(). already know name file (full path well) comes function, possible parse file assign original body function broken one, browser() added.","code":"library(shiny) library(magrittr)  ui <- fluidPage(   modUI(\"mod\"),   textOutput(\"env\"),   actionButton(\"browser\", \"Add browser\") )  server <- function(input, output, session) {   modServer(\"mod\")      output$env <- renderPrint({     findLineNum(\"R/mod.R\", 13)[[1]]$at # check how this changed after the first use of button 'Add browser'   })      observe({     mod_env <- environment(modServer)     body(mod_env$modServer)[[2]][[3]][[3]][[2]][[2]] <- as.call(append(as.list(body(mod_env$modServer)[[2]][[3]][[3]][[2]][[2]]), quote(browser()), 1))     getDefaultReactiveDomain()$reload()   }) %>%      bindEvent(input$browser) }  shinyApp(ui, server) modUI <- function(id) {   ns <- NS(id)   tagList(     numericInput(ns(\"num\"), \"Num\", 0)   ) }  modServer <- function(id) {   moduleServer(     id,     function(input, output, session) {       observe({         input$num       })     }   ) }"},{"path":"https://gsmolinski.github.io/shinybreakpoint/articles/background.html","id":"and-forget-them","dir":"Articles","previous_headings":"I. The Story","what":"And Forget Them","title":"","text":"actions taken now led us state greed; find objects, modify never undo changes; modify , , adding browser()s. can seen previous example - time Add browser button pushed, next browser() added top previous one. Now greed leads us trouble: need escape (using c f) debug mode multiple times escape real - browser() nests us debug mode much worse - browser() persists time observe() runs (runs every time input$num changes), end debug mode remedy remove browser() use, .e. pressing c f (closing) debug mode. must done within function debugged (session reload). words, function remove elements. exemplification mechanism: can see include code removes ; code can added function using function well (example just added beginning, hand). case Shiny app, need remember another session reload necessary equivalent function call (equivalent fun2()). example Shiny app one-time breakpoint. app.R R/mod.R example looks quite complex now, may useful describe (even repeating something) crucial steps: mod_env <- environment(modServer) - just getting environment modServer() function defined - later explained, use body(mod_env$modServer)[[2]][[3]][[3]][[2]][[2]] <- .call(append(.list(body(mod_env$modServer)[[2]][[3]][[3]][[2]][[2]]), quote(browser()), 1)) - browser added body(mod_env$modServer)[[2]][[3]][[3]][[2]][[2]] <- .call(append(.list(body(mod_env$modServer)[[2]][[3]][[3]][[2]][[2]]), quote(env <- environment(modServer)), 2)) - function adding code responsible get environment function defined (.e. function setting breakpoint) body(mod_env$modServer)[[2]][[3]][[3]][[2]][[2]] <- .call(append(.list(body(mod_env$modServer)[[2]][[3]][[3]][[2]][[2]]), quote(body(env$modServer)[[2]][[3]][[3]][[2]][[2]] <- body(env$modServer)[[2]][[3]][[3]][[2]][[2]][-c(2, 3, 4, 5)]), 3)) - adding function code responsible remove added code function body(mod_env$modServer)[[2]][[3]][[3]][[2]][[2]] <- .call(append(.list(body(mod_env$modServer)[[2]][[3]][[3]][[2]][[2]]), quote(getDefaultReactiveDomain()$reload()), 4)) - adding session reload function (session refreshed closing debug mode) getDefaultReactiveDomain()$reload() - reloading session (breakpoint set) interesting useful thing line code can remove next line code, time next line code can still executed - using reload session added code removed remove code responsible reload. Perhaps clearer see , taking example regular function: run function fun2 first time, last element (string \"two\"), removing, returned, run first time, function execute lines code, can check body changed run function , number 2 returned. important, means can add session reload function session reload run (changes can applied) removed function. noted , even looks like retrieving original body function (added elements removed), answer (mentioned earlier) problem element list returned utils::findLineNum() function - still contain wrong indices.","code":"fun2 <- function() {   2   env <- environment(fun2) # get the environment where `fun2` is defined   body(env$fun2) <- body(env$fun2)[-c(3, 4)] }  body(fun2) #> { #>     2 #>     env <- environment(fun2) #>     body(env$fun2) <- body(env$fun2)[-c(3, 4)] #> }  fun2()  body(fun2) #> { #>     2 #> } library(shiny) library(magrittr)  ui <- fluidPage(   modUI(\"mod\"),   actionButton(\"browser\", \"Add browser\"), )  server <- function(input, output, session) {   modServer(\"mod\")      observe({     mod_env <- environment(modServer)     body(mod_env$modServer)[[2]][[3]][[3]][[2]][[2]] <- as.call(append(as.list(body(mod_env$modServer)[[2]][[3]][[3]][[2]][[2]]), quote(browser()), 1))     body(mod_env$modServer)[[2]][[3]][[3]][[2]][[2]] <- as.call(append(as.list(body(mod_env$modServer)[[2]][[3]][[3]][[2]][[2]]), quote(env <- environment(modServer)), 2))     body(mod_env$modServer)[[2]][[3]][[3]][[2]][[2]] <- as.call(append(as.list(body(mod_env$modServer)[[2]][[3]][[3]][[2]][[2]]), quote(body(env$modServer)[[2]][[3]][[3]][[2]][[2]] <- body(env$modServer)[[2]][[3]][[3]][[2]][[2]][-c(2, 3, 4, 5)]), 3))     body(mod_env$modServer)[[2]][[3]][[3]][[2]][[2]] <- as.call(append(as.list(body(mod_env$modServer)[[2]][[3]][[3]][[2]][[2]]), quote(getDefaultReactiveDomain()$reload()), 4))     getDefaultReactiveDomain()$reload()   }) %>%      bindEvent(input$browser) }  shinyApp(ui, server) modUI <- function(id) {   ns <- NS(id)   tagList(     numericInput(ns(\"num\"), \"Num\", 0)   ) }  modServer <- function(id) {   moduleServer(     id,     function(input, output, session) {       observe({         input$num       })     }   ) } fun2 <- function() {   2   env <- environment(fun2)   body(env$fun2) <- body(env$fun2)[-c(3, 4, 5)]   \"two\" }  body(fun2) #> { #>     2 #>     env <- environment(fun2) #>     body(env$fun2) <- body(env$fun2)[-c(3, 4, 5)] #>     \"two\" #> }  fun2() #> [1] \"two\"  body(fun2) #> { #>     2 #> }"},{"path":"https://gsmolinski.github.io/shinybreakpoint/articles/background.html","id":"where-are-you-objects-1","dir":"Articles","previous_headings":"I. The Story","what":"“Where Are You, Objects?”","title":"","text":"one last thing talk - getting (right) environment. examples Shiny app presented now, used environment() get environment object (function), also example regular function remove (within function) elements function. examples personify two aspects important us- necessary get environment object defined necessary precise. code help us answer, need environment: stop thinking problem terms self-referencing, looks simple - can’t modify object defined parent child environment, isolation (function closures environment), however can explicitly refer environment object defined. Now just need remind function defined different environment environment exist function’s elements- defined parent environment. Thus modify function (function) need refer explicitly environment function defined - different example variable . answer, needed refer environment inside function, needed also observe beginning, set breakpoint? one hand, indeed unnecessary - easily refer object directly, (hand) safe - functions name, different environments? refer function, function? environment() returns environment nearest function may enough purposes. see three functions, name live different environment. already know function want refer upper environment (inside function), sure direct parent, can end reference wrong object, - already said - environment() gives us environment nearest object chosen name. previous examples used environment(), just simplicity - see now wasn’t great idea. shinybreakpoint uses something different - function searches environments get needed environment. able refer precise given function, needed know environment. Relatively easy connect object environment upfront, searching objects across environments using code mentioned beginning, .e. lapply(rlang::env_parents(rlang::current_env()), names). first use rlang::env_parents(rlang::current_env()) get list environments get objects list, using lapply() names(). way two lists length every element point environment, problem occur trying use environment code added along browser(). Coming back Shiny app, used line code : constructing env variable environment, know environment contains modServer looking function name, different environment (like showed )? know possible list environments objects (functions) belong given environment, use knowledge? solution won’t work: constructed call (assignment), using variable env environment fun3 defined, call correct - see impossible treat environment like regular value - can’t simply evaluate variable get value. idea bad - already object (fun3) environment (env), just add body function code bind environment name envir. way correct environment refer , see, instead get something like assign(\"envir\", .GlobalEnv), incorrect syntax: assign(\"envir\", <environment>). can, however, keep label environment need search correct environment using label. Label name environment (named) address memory - get label, use rlang::env_label(). expression assign(\"envir\", get_envir(\"global\")) can now added along browser() get right environment - know (example ) \"global\" environment search (function get_envir()) give us precise environment - labels unique. course, still think make sure get_envir() visible environment (function) code added. case Shiny app can stored global environment (objects global environment visible environment app, top environment). case shinybreakpoint, function lives shnybreakpoint environment (namespace), access function problem well (package installed).","code":"a <- 4 fun2 <- function() {   a <- 2 } fun2() a #> [1] 4  a <- 4 fun2 <- function() {   env <- .GlobalEnv   env$a <- 2 } fun2() a #> [1] 2 env_inner <- \"\" env_outer <- \"\"  fun3 <- function() {   fun3 <- function() {     fun3 <- function() {       env_inner <<- environment(fun3)     }     fun3()   }   fun3()   env_outer <<- environment(fun3) }  fun3()  env_inner #> <environment: 0x0000000022e49560>  env_outer #> <environment: 0x0000000022e49678> body(mod_env$modServer)[[2]][[3]][[3]][[2]][[2]] <- as.call(append(as.list(body(mod_env$modServer)[[2]][[3]][[3]][[2]][[2]]), quote(env <- environment(modServer)), 2)) fun3 <- function() {   3 } env <- environment(fun3) # global environment call(\"assign\", \"envir\", env) #> assign(\"envir\", <environment>)  # assign(\"envir\", <environment>) # Error: unexpected '<' in \"assign(\"envir\", <\" fun3 <- function() {   3 } env_lab <- rlang::env_label(environment(fun3))  get_envir <- function(label) {   envirs <- rlang::env_parents(rlang::current_env())   names(envirs) <- lapply(envirs, rlang::env_label)   envirs[[label]] }  call(\"assign\", \"envir\", call(\"get_envir\", env_lab)) #> assign(\"envir\", get_envir(\"global\"))"},{"path":"https://gsmolinski.github.io/shinybreakpoint/articles/background.html","id":"ii--closure","dir":"Articles","previous_headings":"","what":"II. Closure","title":"","text":"Setting breakpoint technique based source code understanding commands executed line--line. source code visible humans - stored like text used read text knowing next statement left, right, . Functions make little complicated - function definition can far, far away line function called, know, received results see, may necessary jump different place file check function body (set breakpoint). Reactive programming makes even complicated - easy know, code block executed input changed. idea storing functions, grouped functions modules separate files try give source code intuitive structure point difference text story text code becomes tangible. even start thinking affinity code text ballast. Isn’t true split source code multiple files want able read text (story) easily possible fragmented text (story)? don’t feel setting breakpoint now selecting text fragment book even writing reading book? course, someone say can use digital tools search text fragment source code book, one important difference story code - story executed brains, code . really need expose source code written text, line? even smaller file - still need always see characters? last chapter summary, idea perhaps useful display source code, relations code blocks belong reactive context minimize exposition developer text far possible; using fact code executed machine, brain, useful display last relation, breakpoint can set somewhere chain relevant output side effect. course new, still matter future, reminded document.","code":""},{"path":"https://gsmolinski.github.io/shinybreakpoint/articles/code.html","id":"overview","dir":"Articles","previous_headings":"","what":"Overview","title":"Code","text":"shinybreakpoint designed display Shiny app (.e. app runs) parts source code used app allow set breakpoint places displayed source code. Thus clear beginning package two-stage limitations: breakpoint can’t set lines displayed breakpoint won’t set lines displayed Setting breakpoint debugging technique - point (line code) reached, code execution halted, debug mode enabled one can check values objects perform operations temporary environment (.e. changes exist debug mode). one method find unexpected behavior occurred. shinybreakpoint provide new technique Shiny apps - already possible set breakpoint using e.g. RStudio IDE, current solution limitation. Breakpoint can’t set code split multiple files (often case app built modules). Although shinybreakpoint gives solution , makes radical way - code split (least one), separated server part, function.","code":""},{"path":"https://gsmolinski.github.io/shinybreakpoint/articles/code.html","id":"setting-breakpoint","dir":"Articles","previous_headings":"","what":"Setting Breakpoint","title":"Code","text":"start snippet1 - minimal skeleton needed successfully run Shiny app shinybreakpoint functionality: similar regular Shiny snippet, however one significant difference - server part duplicated. duplication necessary, breakpoint set using shinybreakpoint, session refreshed enable changes code (changes code added chosen line, .. browser()). Refreshment works objects nested functions call server part. words, breakpoint won’t work objects used directly server, objects visible source code. example works, can consider code . key concept code possibly like set breakpoint separated server (shinybreakpoint::shinybreakpointServer() necessary need use server, used appServer well). app built modules, separation achieved definition, , shinybreakpoint needs additional step. run example , one save file code, run app press F4 (key used default, check parameters running ?shinybreakpoint::shinybreakpointServer console) - modal dialog pop . example two numeric inputs one button UI well two observes (one eager - run immediately one run button pushed) server. observes visible modal dialog breakpoint can set two lines: input$num1 input$num2 possibilities won’t work. Generally can say breakpoint won’t set edges visible code blocks. Immediately breakpoint set (.e. Activate button modal dialog pushed), session refreshed. means breakpoint example set input$num1 line, debug mode open immediately, set input$num2, Go button needs pushed. fact strictly depends reactive programming - debug mode opens code block (breakpoint set) starts chosen line achieved. shinybreakpoint tries find display objects belong reactive context (observes, reactives render*s), however guaranteed objects find objects find. , one remember shinybreakpoint designed work objects belong reactive context thus can lead errors using objects.","code":"library(shiny)  ui <- fluidPage(    )  appServer <- function(input, output, session) {   # here will be the code which will be run in the   # 'server', not in the 'server' itself }  server <- function(input, output, session) {   appServer(input, output, session)   shinybreakpoint::shinybreakpointServer() }  shinyApp(ui, server) library(shiny) library(magrittr)  ui <- fluidPage(   numericInput(\"num1\", \"Num\", 1),   numericInput(\"num2\", \"Num\", 2),   actionButton(\"go\", \"Go\") )  appServer <- function(input, output, session) {   observe({     input$num1   })      observe({     input$num2   }) %>%      bindEvent(input$go) }  server <- function(input, output, session) {   appServer(input, output, session)   shinybreakpoint::shinybreakpointServer() }  shinyApp(ui, server)"},{"path":"https://gsmolinski.github.io/shinybreakpoint/articles/code.html","id":"additional-comments","dir":"Articles","previous_headings":"","what":"Additional Comments","title":"Code","text":"previously mentioned possibly important remarks : debugging performed original file, temporary copy file breakpoint designed one-time breakpoint means breakpoint persist one breakpoint can set one time browser() code added, srcref attribute function lost. However, shouldn’t problem since attribute used get information source object therefore useful debugging session reload twice - first time breakpoint set second one debug mode closed using c f. can inconvenient heavy computations performed session starts one uses RStudio IDE, shinybreakpoint recognizes file opened source editor file used Shiny app contains reactive blocks code, opened default file modal dialog. works moment key specified keyEvent parameter pressed","code":""},{"path":"https://gsmolinski.github.io/shinybreakpoint/articles/debugging.html","id":"reference-to-the-file","dir":"Articles","previous_headings":"","what":"Reference to the file","title":"Debugging","text":"file source()d parse()d, srcref attribute added functions indicate objects originated1. attribute contains code (chosen object) shown file, e.g. comments, also path file. Knowing , possible show user location (file, just body function) computation stops. Unfortunately, body function modified, attribute lost. now distinguish srcref attribute function body() function say attr(fun, \"srcref\") lost, attr(body(fun), \"srcref\"), won’t help us much - still won’t able point original file debug mode starts. solutions course possible show ‘stop’ location file - RStudio displays original file (browser() visible), shinybreakpoint constructs temporary file (temporary location exists long R session - confuse Shiny session) whole added code visible, separated two lines comments - first one indicates additional code starts second one reminds temporary file. Temporary file constructed breakpoint. separate file downsides, course, hand allows modify (temporary) file without fear accompany user working original file. Debug mode just mode read values, possibility execute code convenient way experiment different solutions.","code":""},{"path":"https://gsmolinski.github.io/shinybreakpoint/articles/debugging.html","id":"stepping-through-the-code","dir":"Articles","previous_headings":"","what":"Stepping through the code","title":"Debugging","text":"One way execute code debug mode just type code console move cursor one place another file (copy line execute directly editor Ctrl + Enter shortcut). Another way use shortcuts available debug mode (see ?browser) - like n go next line use panel RStudio buttons dedicated debug mode. context shinybreakpoint two things highlighted. First one exit debug mode without stopping app, c f used - c preferred, f used, RStudio still displays debug mode panels even longer debug mode app runs usual. second one debugging regular functions. Currently shinybreakpoint allows set breakpoint reactive context, doesn’t mean regular functions can’t debugging. , breakpoint set reactive context just function call debug mode option step function call (s dedicated button panel).","code":""},{"path":"https://gsmolinski.github.io/shinybreakpoint/articles/debugging.html","id":"displaying-values","dir":"Articles","previous_headings":"","what":"Displaying values","title":"Debugging","text":"Generally, R value can displayed two ways: using print(var) just typing var console (var variable). n, s shortcuts available debug mode valid variable names, can happen indeed variables names like shortcuts - situation needed use print() display value. However, can also case value won’t displayed, matter method used. case Shiny applications, happens debugging renderPrint, output captured web browser. able display values, necessary call sink() debug mode values can displayed. exiting debug mode, session refreshed, negative consequence using sink().","code":""},{"path":"https://gsmolinski.github.io/shinybreakpoint/articles/debugging.html","id":"one-time-breapoint","dir":"Articles","previous_headings":"","what":"One-time breapoint","title":"Debugging","text":"shinybreakpoint allows set one breakpoint - case breakpoints set, last one saved. Additionally, breakpoint removed exit debug mode - necessary, otherwise end infinite loop breakpoint set reactive context run app (session) starts - ’s session refreshed exiting debug mode. , however, example behavior led situation breakpoint seems persist. web browsers (breakpoint hit) app freezes (loading state), always case - sometimes UI still available. , input change (trigger reactive context breakpoint set ), user end debug mode closing . avoid , UI shouldn’t used debug mode.","code":""},{"path":"https://gsmolinski.github.io/shinybreakpoint/authors.html","id":null,"dir":"","previous_headings":"","what":"Authors","title":"Authors and Citation","text":"Grzegorz Smoliński. Author, maintainer.","code":""},{"path":"https://gsmolinski.github.io/shinybreakpoint/authors.html","id":"citation","dir":"","previous_headings":"","what":"Citation","title":"Authors and Citation","text":"Smoliński G (2022). shinybreakpoint: Set Breakpoint 'Shiny'. https://gsmolinski.github.io/shinybreakpoint/, https://github.com/gsmolinski/shinybreakpoint,.","code":"@Manual{,   title = {shinybreakpoint: Set Breakpoint in 'Shiny'},   author = {Grzegorz Smoliński},   year = {2022},   note = {https://gsmolinski.github.io/shinybreakpoint/, https://github.com/gsmolinski/shinybreakpoint,}, }"},{"path":[]},{"path":"https://gsmolinski.github.io/shinybreakpoint/index.html","id":"description","dir":"","previous_headings":"shinybreakpoint","what":"Description","title":"Set Breakpoint in Shiny","text":"shinybreakpoint Shiny module one can add Shiny application. answer problem setting (editor) breakpoint modules stored separate files - currently possible RStudio IDE. shinybreakpoint breakpoint can set reactive context file making developing modularized Shiny applications easier.","code":""},{"path":"https://gsmolinski.github.io/shinybreakpoint/index.html","id":"installation","dir":"","previous_headings":"shinybreakpoint","what":"Installation","title":"Set Breakpoint in Shiny","text":"can install development version shinybreakpoint GitHub :","code":"# install.packages(\"devtools\") devtools::install_github(\"gsmolinski/shinybreakpoint\")"},{"path":"https://gsmolinski.github.io/shinybreakpoint/index.html","id":"documentation","dir":"","previous_headings":"shinybreakpoint","what":"Documentation","title":"Set Breakpoint in Shiny","text":"See whole documentation Articles section.","code":""},{"path":"https://gsmolinski.github.io/shinybreakpoint/reference/shinybreakpointServer.html","id":null,"dir":"Reference","previous_headings":"","what":"Use Module to Set Breakpoint — shinybreakpointServer","title":"Use Module to Set Breakpoint — shinybreakpointServer","text":"Module Shiny app needed enable functionality setting breakpoint. Must used server part Shiny app function used server part app.","code":""},{"path":"https://gsmolinski.github.io/shinybreakpoint/reference/shinybreakpointServer.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Use Module to Set Breakpoint — shinybreakpointServer","text":"","code":"shinybreakpointServer(   keyEvent = \"F4\",   id = \"shinybreakpoint\",   varName = \"....envirr\" )"},{"path":"https://gsmolinski.github.io/shinybreakpoint/reference/shinybreakpointServer.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Use Module to Set Breakpoint — shinybreakpointServer","text":"keyEvent key run modal dialog functionality set breakpoint. \"F4\" default. id namespace used inputs module. \"shinybreakpoint\" default. Change app module used already \"shinybreakpoint\" namespace. varName setting breakpoint equal inserting browser(), also additional code, one assignment operation. parameter determines variable name assign value. \"....envirr\" default. Change name already use somewhere app.","code":""},{"path":"https://gsmolinski.github.io/shinybreakpoint/reference/shinybreakpointServer.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Use Module to Set Breakpoint — shinybreakpointServer","text":"Used side effect - adds modal dialog Shiny app options set breakpoint. Modal dialog shown key specified keyEvent pressed.","code":""},{"path":"https://gsmolinski.github.io/shinybreakpoint/reference/shinybreakpointServer.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Use Module to Set Breakpoint — shinybreakpointServer","text":"One core concepts founds module necessity re-run objects present server part app. possible objects live directly server, function used server. naturally harmonizes modules, needs separate function objects used directly server (see example).","code":""},{"path":"https://gsmolinski.github.io/shinybreakpoint/reference/shinybreakpointServer.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Use Module to Set Breakpoint — shinybreakpointServer","text":"","code":"# To run example, copy-paste to file, save the file # and run the app. Then press \"F4\" to open the modal dialog. # Make sure 'bslib' package is installed.  if (FALSE) {  # install.packages(\"bslib\") if needed library(shiny)  appServer <- function(input, output, session) {   observe({     input$num   }) }  shinyApp(   ui = fluidPage(     theme = bslib::bs_theme(5),     numericInput(\"num\", \"Num\", 0)   ),   server = function(input, output, session) {     shinybreakpoint::shinybreakpointServer()     appServer(input, output, session)   } ) }"},{"path":"https://gsmolinski.github.io/shinybreakpoint/reference/snippet.html","id":null,"dir":"Reference","previous_headings":"","what":"Write (Append) Basic Shiny App With Shinybreakpoint Functionality — snippet","title":"Write (Append) Basic Shiny App With Shinybreakpoint Functionality — snippet","text":"Append code skeleton shinybreakpoint functionality active (opened) file RStudio.","code":""},{"path":"https://gsmolinski.github.io/shinybreakpoint/reference/snippet.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Write (Append) Basic Shiny App With Shinybreakpoint Functionality — snippet","text":"","code":"snippet()"},{"path":"https://gsmolinski.github.io/shinybreakpoint/reference/snippet.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Write (Append) Basic Shiny App With Shinybreakpoint Functionality — snippet","text":"Appends code skeleton file.","code":""},{"path":"https://gsmolinski.github.io/shinybreakpoint/reference/snippet.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Write (Append) Basic Shiny App With Shinybreakpoint Functionality — snippet","text":"shinybreakpoint needs server logic included function separated 'server' part app also developed Bootstrap version 5 mind. snippet takes care . Snippet also available addin.","code":""},{"path":"https://gsmolinski.github.io/shinybreakpoint/reference/snippet.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Write (Append) Basic Shiny App With Shinybreakpoint Functionality — snippet","text":"","code":"if (FALSE) { # use shinybreakpoint::snippet() in the Console in RStudio # if there is an opened file (in Source Editor), # then this skeleton should be added to the file: library(shiny)  ui <- fluidPage(   theme = bslib::bs_theme(5), )  appServer <- function(input, output, session) {  }  server <- function(input, output, session) {   shinybreakpoint::shinybreakpointServer() # TODO: remove   appServer(input, output, session) }  shinyApp(ui, server) }"},{"path":"https://gsmolinski.github.io/shinybreakpoint/news/index.html","id":"shinybreakpoint-001","dir":"Changelog","previous_headings":"","what":"shinybreakpoint 0.0.1","title":"shinybreakpoint 0.0.1","text":"First version","code":""}]
