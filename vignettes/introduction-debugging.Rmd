---
title: '"What about trace()?". Two Introductions'
output: rmarkdown::html_vignette
vignette: >
  %\VignetteIndexEntry{"What about trace()?". Two Introductions}
  %\VignetteEngine{knitr::rmarkdown}
  %\VignetteEncoding{UTF-8}
---

```{r, include = FALSE}
knitr::opts_chunk$set(
  collapse = TRUE,
  comment = "#>"
)
```

## I. The Code

### Overview

`shinybreakpoint` is designed to display in the Shiny app (i.e. when the app runs) parts of the source code used in the app and to allow to set breakpoint in *some* places of the displayed source code. Thus it should be clear from the beginning that this package has two-stage limitations:

-   breakpoint can't be set on the lines which are *not* displayed
-   breakpoint won't be set on *all* lines which are displayed

Setting breakpoint is a debugging technique - when the point (line of code) is reached, code execution is halted, debug mode is enabled and one can check the values of objects or perform any other operations in the temporary environment (i.e. all changes exist only in the debug mode). It is one of the method to find out why unexpected behavior occurred.

`shinybreakpoint` do not provide *new* technique for Shiny apps - it is already possible to set breakpoint using e.g. RStudio IDE, but the current solution has its own limitation. Breakpoint can't be set when the code is split into multiple files (which is often the case when app is built of modules). Although `shinybreakpoint` gives the solution for that, it makes it in the radical way - the code has to be split into (at least one), separated from `server` part, function.

### Usage

#### Setting Breakpoint

We will start from the snippet - minimal skeleton needed to successfully run the Shiny app with the `shinybreakpoint` functionality:

    library(shiny)

    ui <- fluidPage(
      
    )

    appServer <- function(input, output, session) {
      # here will be the code which will be run in the
      # 'server', not in the 'server' itself
    }

    server <- function(input, output, session) {
      appServer(input, output, session)
      shinybreakpoint::shinybreakpointServer()
    }

    shinyApp(ui, server)

it is very similar to the regular Shiny snippet, however with the one significant difference - the server part is duplicated.

This duplication is necessary, because when the breakpoint is set using `shinybreakpoint`, the session is refreshed to enable changes in the code (these changes are the code added to the chosen line, i.a. `browser()`). Refreshment works only for objects nested in the functions which are then call in the `server` part. In other words, breakpoint won't work for objects used directly in the `server`, but these objects will be visible in the source code. As an example that works, we can consider the code below.

    library(shiny)
    library(magrittr)

    ui <- fluidPage(
      numericInput("num1", "Num", 1),
      numericInput("num2", "Num", 2),
      actionButton("go", "Go")
    )

    appServer <- function(input, output, session) {
      observe({
        input$num1
      })
      
      observe({
        input$num2
      }) %>% 
        bindEvent(input$go)
    }

    server <- function(input, output, session) {
      appServer(input, output, session)
      shinybreakpoint::shinybreakpointServer()
    }

    shinyApp(ui, server)

The key concept is that all code on which we possibly would like to set breakpoint is separated from the `server` (`shinybreakpoint::shinybreakpointServer()` does not necessary need to be use in the `server`, it could be used in the `appServer` as well). When the app is built of modules, this separation is achieved *by definition*, but when not, then `shinybreakpoint` needs this additional step.

To run the example above, one should save the file with the code, run the app and press `F1` (as this is key used by default, check out the other parameters by running `?shinybreakpoint::shinybreakpointServer` in the console) - the modal dialog will pop up. In our example there are two numeric inputs and one button in the `UI` as well as two `observe`s (one is *eager* - will run immediately and one will run only after the button is pushed) in the `server`. `observe`s will be visible in the modal dialog and breakpoint can be set on two lines:

-   `input$num1` and
-   `input$num2`

other possibilities won't work. Generally we can say that breakpoint won't be set on the *edges* of the visible code blocks.

Immediately after the breakpoint is set (i.e. when the `Activate` button in the modal dialog is pushed), session is refreshed. That means that if the breakpoint in our example was set on the `input$num1` line, debug mode will open up immediately, but if it was set on the `input$num2`, then `Go` button needs to be pushed. That fact strictly depends on the reactive programming - debug mode opens up when the code block (where breakpoint is set) starts and the chosen line is achieved.

Before we move into debug mode, something more has to be said about *visible code blocks*. `shinybreakpoint` tries to find and display only objects which belong to *reactive context* (`observe`s, `reactive`s and `render*`s), however it is not guaranteed that *all* of these objects will be find and that *only* these objects will be find. If so, one should remember that `shinybreakpoint` was designed to work with objects which belong to reactive context and thus it can lead to errors if using on other objects.

#### Debug Mode

As already said, debug mode is an (temporary) environment when is possible to run arbitrary code and thus is very helpful to check if e.g. variables have the expected values. Although this vignette is not about debugging (many helpful documents are possible to find easy), some things in the context of the `shinybreakpoint` package should be highlighted.

Setting breakpoint is nothing more than inserting `browser()` in some place of code, but `shinybreakpoint` inserts more than this. All of the added code (in total four lines of code) is harmless, but will be visible in the debug mode. It can be run (if one would like to step down line-by-line) or ignore.

Breakpoint is constructed to be a one-time breakpoint, which means that after pressing `c` or `f` in the debug mode, Shiny app won't have active breakpoint anymore (to set it again, modal dialog delivered by `shinybreakpoint` must be use again). There is, however, case when it could look like the breakpoint persist - during the debug mode, the app still runs and the objects in `UI` can be use. If we take as an example our example above, we could notice the following behavior: set the breakpoint on `input$num1` line, activate it and during the debug mode, change the `input$num1` in the app - then when we press `c` in the debug mode (to continue execution of code to the end of block and then exit), we will notice that we end up in the debug mode again, but now with the different value of `input$num1`. If we decide to change again `input$num1` in the app, this situation will repeat, but if not, the debug mode will close successfully after pressing `c`. To avoid this problem, we can generally say that *it is not recommended to use app during the debug mode*.

And the last thing - if something is displayed on the screen in the app, it can be impossible to see its value just be typing the variable name in the debug mode, and it can be necessary to use `sink()` before (in the debug mode). In our example that would be the case if we would have `renderPrint` where we would like to display `input$num1`.

### Additional Comments

Not previously mentioned and possibly important remarks are:

- when the `browser()` and other code is added, the `srcref` attribute of function is lost. However, it shouldn't be a problem since this attribute is used to get information about the source of object and therefore is useful only for debugging
- session is reload twice - first time after the breakpoint is set and the second one when debug mode is closed using `c` or `f`. This can be inconvenient if some heavy computations are performed when the session starts

## II. The Story

### The Myth

In his talk given at 2016 Shiny Developer Conference, Jonathan McPherson noticed:

> If you're a seasoned R programmer, you may have used the `trace()` function to add tracing without modifying your script. Unfortunately, it's not possible to use this utility (or any that depend on it, such as `setBreakpoint`) with Shiny. `trace()` works by rewriting the body of the function to be traced, so the function must already exist when you run it. Shiny generates functions at runtime that aren't easily addressable.

It was a fragment titled "What about trace()?" and is now available as a official documentation for Shiny ([Debugging Shiny applications](https://shiny.rstudio.com/articles/debugging.html)). And we could say it is somehow *suspicious*, since in the same paragraph we have that something is impossible, because other thing is not *easily* addressable, but not - as we could expect - *impossible* to be addressable. It's a good paragraph to start with, even that by saying that everything started, because of this suspicion, would be nothing more than founding myth.

### Where Are You, Objects?

Our aim will be the modification of the body of function to insert `browser()` there, but at first we need to find all functions. We can do this using `lapply(rlang::env_parents(rlang::current_env()), names)` in the example below:

**app.R**

```
library(shiny)

ui <- fluidPage(
  modUI("mod"),
  textOutput("env")
)

server <- function(input, output, session) {
  modServer("mod")
  
  output$env <- renderPrint({
    lapply(rlang::env_parents(rlang::current_env()), names)
  })
}

shinyApp(ui, server)
```

**R/mod.R**

```
modUI <- function(id) {
  ns <- NS(id)
  tagList(
    numericInput(ns("num"), "Num", 0)
  )
}

modServer <- function(id) {
  moduleServer(
    id,
    function(input, output, session) {
    }
  )
}
```

By running this, we will learn that the structure of objects in the Shiny app have the following characteristic:

- on the top (or: as the parent) is `global` environment, but in our example it doesn't contain any objects created by us
- next, going from the top to the bottom (i.e. to the first child) we will find the objects from our module (saved in *R/mod.R* file) - `UI` and `server` part (but named as `modUI` and `modServer`)
- finally, as the grandchild we see the objects from the file where we have started - `server` and `ui` from *app.R* file (we can ignore the rest of the objects and environments)

This is, of course, the evidence that documentation was right:

> all R code in a Shiny app is run in the global environment or a child of it^[[Scoping rules for Shiny apps](https://shiny.rstudio.com/articles/scoping.html)]

Now, because we were able to find the objects (and our search was very precise - we also get the environments where these objects live), we can try to modify them.

### And Where Are Your Elements?

We want to modify *body* of function and we will use `body()` for this. Not trying to be precise, but just useful for our purposes, we can say that `body()` returns *very* complex list.

```
fun1 <- function() {
  x <- 2
  x
}

fun_env <- environment(fun1) # get environment where `fun1` is defined

body(fun_env$fun1)
#> {
#>     x <- 2
#>     x
#> }

body(fun_env$fun1)[[2]]
#> x <- 2
body(fun_env$fun1)[[2]][[1]]
#> `<-`
```
This list can be manipulate - elements can be added, removed etc. We just need some additional functions for this, like `as.list()` (so we can use `append()`), `as.call()` (to turn back the list into `language` object):

```
fun1 <- function() {
  x <- 2
  x
}

fun_env <- environment(fun1)

body(fun_env$fun1) <- as.call(append(as.list(body(fun_env$fun1)), quote(browser()), 1))

fun1()
```
now the `fun1()` call will move us into debug mode. Let's do the same in Shiny app:

**app.R**

```
library(shiny)
library(magrittr)

ui <- fluidPage(
  modUI("mod"),
  textOutput("env"),
  actionButton("browser", "Add browser")
)

server <- function(input, output, session) {
  modServer("mod")
  
  output$env <- renderPrint({
    mod_env <- environment(modServer)
    as.list(body(mod_env$modServer)[[2]][[3]][[3]][[2]][[2]])
  })
  
  observe({
    mod_env <- environment(modServer)
    body(mod_env$modServer)[[2]][[3]][[3]][[2]][[2]] <- as.call(append(as.list(body(mod_env$modServer)[[2]][[3]][[3]][[2]][[2]]), quote(browser()), 1))
  }) %>% 
    bindEvent(input$browser)
}

shinyApp(ui, server)
```

**R/mod.R**

```
modUI <- function(id) {
  ns <- NS(id)
  tagList(
    numericInput(ns("num"), "Num", 0)
  )
}

modServer <- function(id) {
  moduleServer(
    id,
    function(input, output, session) {
      observe({
        input$num
      })
    }
  )
}
```
We can notice that when `Add browser` button is pushed, nothing happens. However, it is not true - `browser()` is added, but moving back to our example with `fun1()` function, we are still here:

```
body(fun_env$fun1) <- as.call(append(as.list(body(fun_env$fun1)), quote(browser()), 1))
```
i.e. `browser()` was added, but we didn't yet run the function again. We can achieve this by refreshing the session - manually, refreshing the app in the web browser or adding `getDefaultReactiveDomain()$reload()` to reload the session:

**app.R**

```
library(shiny)
library(magrittr)

ui <- fluidPage(
  modUI("mod"),
  textOutput("env"),
  actionButton("browser", "Add browser")
)

server <- function(input, output, session) {
  modServer("mod")
  
  output$env <- renderPrint({
    mod_env <- environment(modServer)
    as.list(body(mod_env$modServer)[[2]][[3]][[3]][[2]][[2]])
  })
  
  observe({
    mod_env <- environment(modServer)
    body(mod_env$modServer)[[2]][[3]][[3]][[2]][[2]] <- as.call(append(as.list(body(mod_env$modServer)[[2]][[3]][[3]][[2]][[2]]), quote(browser()), 1))
    getDefaultReactiveDomain()$reload() # added
  }) %>% 
    bindEvent(input$browser)
}

shinyApp(ui, server)
```

Doing this, we re-run the `modServer()` function.

### Find Them Again (And Again)

Among other (not yet mentioned) problems, we still need a tools to find *where* to insert `browser()`, because until now we have just used our eyes. This is somehow secondary issue as we mainly would like to show in this vignette the core concept of setting breakpoint, even if *by hand*, so solutions below are rather only signaled.

Having a (named) function, which is in a saved file (which was `source()`d), we can use the following functions:

- `utils::getParseData()` to get the `data.frame` needed to reconstruct the whole script in this saved file (`utils::getParseText()` can be useful in this context as well)
- `utils::getSrcFilename()` to get the name of the file
- `utils::findLineNum()` to get the (1) name of the object; (2) environment where this object lives; (3) location in the body of this object based on line number in the script (i.e. which indices to use to get the right location when using `body()[[]]`)

However, we quickly find that after modifying the body of function, we broke it up - `utils::findLineNum()` no longer returns the correct indices (`at` element of returned list):

**app.R**

```
library(shiny)
library(magrittr)

ui <- fluidPage(
  modUI("mod"),
  textOutput("env"),
  actionButton("browser", "Add browser")
)

server <- function(input, output, session) {
  modServer("mod")
  
  output$env <- renderPrint({
    findLineNum("R/mod.R", 13)[[1]]$at # check how this changed after the first use of button 'Add browser'
  })
  
  observe({
    mod_env <- environment(modServer)
    body(mod_env$modServer)[[2]][[3]][[3]][[2]][[2]] <- as.call(append(as.list(body(mod_env$modServer)[[2]][[3]][[3]][[2]][[2]]), quote(browser()), 1))
    getDefaultReactiveDomain()$reload()
  }) %>% 
    bindEvent(input$browser)
}

shinyApp(ui, server)
```
**R/mod.R**

```
modUI <- function(id) {
  ns <- NS(id)
  tagList(
    numericInput(ns("num"), "Num", 0)
  )
}

modServer <- function(id) {
  moduleServer(
    id,
    function(input, output, session) {
      observe({
        input$num
      })
    }
  )
}
```
In the example above, we display the `at` element of returned list - when the `Add browser` button is pushed by the first time (and after that the debug mode is closed by pressing `c` or `f`), we can see that the displayed indices changed and we no longer can use this element to find the correct location in the body of function. In other words, our code now works just one time - after the first use, the app should be closed and run again (if `at` would be use to determine the location of body, of course; in the example above we are still using hard-coded location). To resolve this problem, we need to retrieve the original body of object (function) - one way to do this would be to use `parse()`. We already know the name of file (and full path as well) from which comes the function, so it is possible to parse the file and assign the original body of function to the broken one, before the `browser()` is added.

### And Forget Them

All of our actions taken until now led us to the state of greed; we find objects, modify them and never undo the changes; and then we modify them again, again, adding more `browser()`s. This can be seen in our previous example - each time the `Add browser` button is pushed, next `browser()` is added at the top of the previous one. Now this greed leads us into trouble:

- we need to escape (using `c` or `f`) from debug mode multiple times before we escape for real - each `browser()` nests us into debug mode
- but what is much worse - the `browser()` persists and each time the `observe()` runs (and it runs every time the `input$num` changes), we end up in the debug mode


